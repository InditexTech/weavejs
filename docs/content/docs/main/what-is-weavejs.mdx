---
title: What is Weave.js?
description: Introducing Weave.js a visual collaborative web applications framework
---

import { Separator } from "@/components/separator";
import { Tags, Tag } from "@/components/tags";

## Introduction

<Callout title="Intentionally opinionated">
  Weave.js is intentionally opinionated in its design choices, promoting best
  practices and consistency in architecture, while still offering flexibility
  for customization. This makes it especially well-suited for teams and projects
  aiming to deliver rich, collaborative visual experiences with minimal
  boilerplate and maximal control.
</Callout>

Weave.js is a JavaScript library purpose-built for developing visual collaborative
tools on top of the HTML5 canvas. It provides a structured and extensible foundation
for building real-time, multi-user interfaces such as whiteboards, diagram editors,
visual programming environments, and other interactive graphical tools.

At its core, Weave.js embraces a plugin-based architecture, allowing
developers - without compromising performance or maintainability - to easily handle:

### Canvas rendering

Weave.js provides an easy way to handle most of the canvas rendering logic and interactions
and also provide it's own rendering life-cycle.

<Separator />

For this we introduce some abstractions, like: [Node](/docs/headless/architecture/nodes)
and [Plugin](/docs/headless/architecture/plugins), to provide a single way to manage
the canvas and extend functionality.

By default we also include some [base nodes](/docs/main/base/nodes) and
[base plugins](/docs/main/base/plugins) to get started asap.

### Real-time state synchronization

Weave.js provides all the tools necessary to handle the backend & frontend (client) logic to
support real-time collaboration on top different transports.

<Separator />

For this we introduce an abstraction named the [Store](/docs/headless/architecture/stores)

By default we also include some [base stores](/docs/main/base/stores) to get started asap.

### Users interactions

Weave.js provides a simple API to build custom users interactions. Separating rendering from
interactions allow to build more easily features on top of the collaborative visual applications.

<Separator />

For this we introduce an abstraction named the [Action](/docs/headless/architecture/actions).
To provide an unique API to handle this interactions.

By default we also include some [base actions](/docs/main/base/actions) to get started asap.

<Callout title="End-to-end solution">
  We offer an end-to-end (front and backend) solution with high-level
  abstractions, significantly reducing the complexity typically involved in
  building such applications from scratch.
</Callout>

## How does it work?

Weave.js is built on a modern, modular architecture that integrates best-in-class open-source
libraries to simplify and streamline the development of visual collaborative tools.

Our goal is to abstract all the complexity of real-time collaboration and canvas rendering, so
developers can focus on **building features**, not infrastructure.

Internally Weave.js uses profusely the following top-notch OSO libraries:

### Konva.js

<Tags>
  <Tag color="lime">FRONTEND</Tag>
</Tags>

We use [Konva.js](https://konvajs.org/docs/overview.html) to manage and simplify
the HTML5 canvas rendering. Its high-level abstraction over the HTML5 canvas API
simplifies the process of creating and manipulating canvas primitives which are the
canvas building blocks.

### React Reconciler

<Tags>
  <Tag color="lime">FRONTEND</Tag>
</Tags>

We use a custom [React Reconciler](https://github.com/facebook/react/tree/main/packages/react-reconciler)
to bridge React’s component model state with the Konva rendering process. This integration allows
developers to declaratively manage the canvas node tree, while benefiting from efficient, incremental
updates and the internal React's renderer life-cycle optimizations.

### Yjs

<Tags>
  <Tag color="lime">FRONTEND</Tag>
  <Tag color="red">BACKEND</Tag>
</Tags>

Real-time collaboration is part of our core, to handle all the heavy-lifting about the shared-state,
network and client management we use [Yjs](https://yjs.dev), an [CRDT](https://github.com/yjs/yjs/blob/master/README.md#Yjs-CRDT-Algorithm)-based
framework that ensures consistency across distributed clients.

It handles network conflicts automatically, guarantees that all users stay in sync, even during offline
or concurrent edits and support awareness events sharing. Also allows to persist the shared-state in an
agnostic and custom way.

### SyncedStore

<Tags>
  <Tag color="lime">FRONTEND</Tag>
</Tags>

We use [SyncedStore](https://syncedstore.org/docs), an API for Yjs, to provide a developer-friendly
abstraction layer. SyncedStore offers a simple, reactive API that makes working with shared-state feel
like building a regular single-user app—while seamlessly handling all the multiplayer complexity under the hood.

Together, these technologies form the backbone of **Weave.js**: a cohesive system that enables developers
to build scalable, collaborative canvas tools with minimal friction. Whether you're building a live whiteboard,
a flowchart editor, or a visual programming interface, Weave.js provides the infrastructure you need—without
reinventing the wheel.

## UI Framework agnostic

Weave.js is agnostic of the UI framework you use, building your app UI is a project
responsibility, we just provide the glue to make it smooth.

You can install Weave.js on top of any UI framework, such as Next.js, React, Angular, or Vue.
But we do provide and maintain some easing tools for the React integration (providers and hooks)

## Common project architecture

A standard **Weave.js** project follows a frontend-backend architecture designed to support real-time,
collaborative experiences with efficient state synchronization and persistence.

<Callout title="On production..." type="warn">
  We recommend to separate the frontend and backend sides into different
  artifacts for production environments, but it's also possible to have both on
  the same artifact, as we'll see on our [Quick Start](/docs/main/quickstart)
  where we use a Next.js project.
</Callout>

## The Frontend artifact

Normally the frontend artifact is built with a modern web UI framework, commonly React, Vue, etc. We provide an SDK
and a complimentary library - like the React helper library we provide - to create the visual collaborative interface.

Weave.js logically for the frontend side perspective handles:

- **Canvas rendering**: handles all the canvas rendering and life-cycle via Konva.js elements and the React Reconciler
  life-cycle.
- **Real-time state synchronization**: we provide clients to connect to the backend, allowing to manage the real-time collaboration,
  via Yjs and SyncedStore.
- **User interaction**: via our plugin system, enabling custom drawing nodes, actions or plugins for the UI logic.

The SDK provides and handles our abstractions, which are:

### Nodes

Nodes are the API we define to provide a seamlessly way to facilitate and handle the rendering of a node on the canvas.

### Plugins

Plugins are the API we define to empower the canvas functionality, normally a plugin don't provide user interaction.
For example a plugin can be defined to give the ability to handle zooming-in or zooming-out of the canvas.

### Actions

Actions are the API we define to handle user interaction over the canvas. For example when an user wants to add a node
to the canvas, or to provide an action to trigger a plugin method.

## The Backend artifact

Normally the backend artifact is build with Node.js on top a server framework like Express, Koa, etc. We provide
Stores, which are our abstraction to handle all things related to the shared-state on the backend side. The store
is mainly responsible for:

### Interface to persist and retrieve the shared-state

Persistence or retrieval of the shared-state is completely handled by the developer. Weave.js Stores provides an easy
API to manage the shared-state: retrieve a state or persist the state in a custom provider (file system, blob storage, etc.),
so where to persist it, that's up to the project.

For example in our showcase we save the shared-state binary files directly over an
[Azure Blob Storage](https://azure.microsoft.com/es-es/products/storage/blobs). And we also recover it for there.

### Real-time sharing and transport of the shared-state

This is done using one of Weave.js’s supported store providers, internally they use Yjs as the shared-state manager. We provide
the following store providers as today:

- **Websockets Store**, which uses the [Websockets API](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API) as
  transport.
- **Azure Web PubSub Store**, which uses [Azure Web PubSub](https://azure.microsoft.com/en-us/products/web-pubsub)
  as transport.

Developers can also write their own Store with their custom transport. For example like using AWS AppSync as transport.

### Awareness events

<Tags>
  <Tag color="amber">OPTIONAL</Tag>
</Tags>

Awareness events are fundamental part of a collaborative application. The first part of a collaborative application in
order to work seamlessly among all clients is to manage and sync a shared-state that models our application. But we also
can share more information that helps our users to work together, for example let know when an user joins or leaves the
collaboration room or when a user is performing an action, etc. This kind of information is generally denominated as
**Awareness** information.

We could share a lot of awareness information like for example mouse position of each user. But when we share too much
awareness information, we distract our users from the task at hand. So it is important to find the right balance, that
makes sense for your application.

Awareness information isn't stored in the shared-state, as it doesn't need to be persisted across sessions. We relay on
Yjs [awareness](https://docs.yjs.dev/getting-started/adding-awareness) mechanism that propagates JSON objects to all users.

All of our Stores implement the Awareness protocol.
