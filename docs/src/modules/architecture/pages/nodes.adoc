= Nodes

In **Weave.js**, a **Node** is the fundamental unit of visual content, a self-contained,
interactive element that lives on the canvas. **Nodes** are used to represent everything
from basic shapes like rectangles and ellipses to complex components like connectors,
labels, frames or even entire groups of other nodes.

Under the hood, a **Node** is typically built on top of Konva.js shapes, and wrapped with
additional logic that makes it reactive, interactive, and collaborative within the **Weave.js**
ecosystem.

**Weave.js** includes a set of built-in Nodes, but you can also create your own to tailor
functionality to your specific application needs. 

== Node lifecycle

**Weave.js** node lifecycle is the following:

. Weave instance is started.
. Nodes are registered, the `getNodeType` method is used to identify the node.
. When a node is created / updated / removed, the node in its declarative form is
added / updated / removed from the shared-state.
. The new shared-state is then sent to the https://github.com/facebook/react/tree/main/packages/react-reconciler[React Reconciler]
instance, which transforms the shared-state declarative form to the Konva.js renderer one.
. Other peers also receive this updated shared-state, and their React Reconciler
proceed the same way.

== How to share a Node?

First of all, lets take into account that **Nodes** are the core part of the shared-state,
and this state is shared with all other users, so we need a way to transform an user canvases
(which is basic Konva.js instances) into a model we can share over the wire.

**Weave.js** defines an implementation for a _two-way mapping mechanism_, in order to be able
to define and share **Nodes** over the wire with other peers. This _two-way mapping mechanism_
works like this:

* First one maps Konva.js instances rendered on an user canvas, to a JSON model, so we can
transport this model over the line and share it with other peers.
* Secondly, the peers can map this JSON model back to a Konva.js instance so they can replicate 
the **Node** on they respective canvases.

== Node declarative form

As we use the React Reconciler, we can benefit to use React components declarative definition.
This way **Nodes** are expressed as a JSON object in the same shape as a React component, the
shape of this JSON object is:

[source,typescript]
----
include::nodes:example$declarative-form.json[]
----
<1> *key*: [string] an unique string that identifies the node instance in all the nodes hierarchy.
<2> *type*: [string] an string that defines the node type, i.e. `rectangle` for a Rectangle node. 
<3> *props*: [object] an object defining the properties of the node, just like in a React component.

Also, take into consideration that `props` must always define a property named `children`,
which is defined as an Array of this same JSON definition. The `children` property define
the tree hierarchy of the nodes - similar to the HTML hierarchy -.

If the node is a leaf, then `children` is an empty Array (`[]`), or if not, is an Array
with N elements defined as the previous JSON shape.

== WeaveNodeBase abstract class

All **Nodes** in **Weave.js** extends the abstract class
https://github.com/InditexTech/weavejs/blob/main/code/packages/sdk/src/nodes/node.ts[WeaveNodeBase],
which provides a set of common methods that help us standardize the implementation of the _two-way
mapping mechanism_.

So, to define and build a **Node** in **Weave.js** is as simple as extend the abstract class 
`WeaveNodeBase` and implement a set of methods.

You can access **Weave.js** main instance via `this.instance`.

Lets now take a deep look into the `WeaveNodeBase` abstract class properties and methods:

=== nodeType

The `nodeType` string property, defines the type of node.

=== createNode

[source,typescript]
----
abstract createNode(id: string, props: WeaveElementAttributes): WeaveStateElement;
----

The method `createNode` is responsible for define the **Node** in a declarative way, in
our case using the **Node** declarative form.

As you can see on the method we receive:

* An `id`, which can be used as `key`.
* The `props` defined for the instance.

=== createInstance

[source,typescript]
----
abstract createInstance(props: WeaveElementAttributes): WeaveElementInstance;
----

The method `createInstance` is responsible for translating the **Node** declarative way (or definition)
to a real Konva.js instance to be used on a canvas. The method return the Konva.js instance that represents
this node.

As you can extrapolate this method is the one responsible for the first part of the _two-way mapping mechanism_.

We receive on the method the `props` defined for the **Node**, so we can use them or translate them to
Konva.js shape properties.

=== updateInstance

[source,typescript]
----
abstract updateInstance(instance: WeaveElementInstance, nextProps: WeaveElementAttributes): void;
----

The method `updateInstance` is responsible for updating the Konva.js instance produced by `createInstance`.

We receive the Konva.js instance to update (previously created) and the `nextProps` which are the new set of
`props` for the **Node**.

[WARNING]
====
Don't create any Konva.js instance in this method.
====

=== removeInstance

[source,typescript]
----
abstract removeInstance(instance: WeaveElementInstance): void;
----

The method `removeInstance` is responsible for removing the Konva.js instance produced by `createInstance`.

We receive the Konva.js instance to remove (previously created).

=== toNode

[source,typescript]
----
abstract toNode(instance: WeaveElementInstance): WeaveStateElement;
----

The method `toNode` is responsible to map a Konva.js instance to the **Node** declarative form.

As you can extrapolate this method is the one responsible for the second part of the _two-way mapping mechanism_.

We receive the Konva.js instance to map.
