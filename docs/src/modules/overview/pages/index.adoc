= Overview

== What's Weave.js?

**Weave.js** is an opinionated JavaScript library purpose-built for developing visual
collaborative tools on top of the HTML5 canvas. It provides a structured and extensible
foundation for building real-time, multi-user interfaces such as whiteboards, diagram editors,
visual programming environments, and other interactive graphical tools.

At its core, **Weave.js** embraces a plugin-based architecture, allowing developers to
easily extend and customize behaviors, nodes (rendering logic), tools and actions without
compromising performance or maintainability. The library offers an end-to-end (front and backend)
solution with high-level abstractions for managing:

- Canvas rendering
- Real-time state synchronization
- User interactions

Significantly reducing the complexity typically involved in building such applications from scratch.

[NOTE]
====
**Weave.js** is intentionally opinionated in its design choices, promoting best practices and
consistency in architecture, while still offering flexibility for customization. This makes it
especially well-suited for teams and projects aiming to deliver rich, collaborative visual experiences
with minimal boilerplate and maximal control.
====

== How does it work?

**Weave.js** is built on a modern, modular architecture that integrates best-in-class open-source
libraries to simplify and streamline the development of visual collaborative tools.

Our goal is to abstract all the complexity of real-time collaboration and canvas rendering, so
developers can focus on _building features_, not _infrastructure_.

Internally **Weave.js** core uses profusely the following top-notch OSO libraries:

* Konva.js
* React Reconciler
* Yjs
* SyncedStore

'''

=== Konva.js

We use https://konvajs.org/docs/overview.html[_Konva.js_] to manage and simplify the HTML5 canvas
rendering. Its high-level abstraction over the HTML5 canvas API simplifies the process of creating
and manipulating primitives, shapes, groups, and layers which are the canvas building blocks.

=== React Reconciler

We use a custom https://github.com/facebook/react/tree/main/packages/react-reconciler[_React Reconciler_]
to bridge React’s component model state with the Konva rendering process. This integration allows
developers to declaratively manage the canvas node tree, while benefiting from efficient, incremental
updates and the internal React's renderer life-cycle optimizations.

=== Yjs

Real-time collaboration is part of our core, to handle all the heavy-lifting about the shared-state,
network and client management we use https://yjs.dev[_Yjs_], a https://github.com/yjs/yjs/blob/master/README.md#Yjs-CRDT-Algorithm[CRDT]-based
framework that ensures consistency across distributed clients.

It handles network conflicts automatically, guarantees that all users stay in sync, even during offline
or concurrent edits and support awareness events sharing. Also allows to persist the shared-state in an
agnostic and custom way.

=== SyncedStore

We use https://syncedstore.org/docs[_SyncedStore_], an API for _Yjs_, to provide a developer-friendly
abstraction layer. _SyncedStore_ offers a simple, reactive API that makes working with shared-state feel
like building a regular single-user app—while seamlessly handling all the multiplayer complexity under the hood.

'''

Together, these technologies form the backbone of **Weave.js**: a cohesive system that enables developers
to build scalable, collaborative canvas tools with minimal friction. Whether you're building a live whiteboard,
a flowchart editor, or a visual programming interface, Weave.js provides the infrastructure you need—without
reinventing the wheel.

== Common project architecture

A standard **Weave.js** project follows a frontend-backend architecture designed to support real-time,
collaborative experiences with efficient state synchronization and persistence.

[NOTE]
====
We recommend to separate the frontend and backend sides into different artifacts, but it's also possible
to have both on the same artifact, as we'll see on the Quickstart with a _Next.js_ project.
====

=== Frontend artifact

Normally the frontend artifact is built with modern web frameworks, commonly React, Vue, etc. We provide an SDK
and complimentary library - like the React helper library we provide - to create the visual collaborative interface.

The frontend side from the **Weave.js** perspective handles:

* The **canvas rendering** via _Konva.js_ elements and the _React Reconciler_ life-cycle.
* **User interaction** via our plugin system, enabling custom drawing nodes, actions or plugins for the UI logic.
* A client to manage the real-time collaboration, integrating _Yjs_ and _SyncedStore_, which provides reactive shared
state synced across users.

=== Backend artifact

Normally the backend artifact is build with Node.js on top a server framework like Express, Koa, etc. We provide
stores, that are an abstraction to handle all things related to the shared-state on the backend side. The store
is responsible for:

'''

==== Interface to persist and retrieve the shared-state

Normally is handled by the developer, **Weave.js** stores provides an easy API to retrieve the shared-state and to persist it
in a custom way. For example in our showcase we save the shared-state on binary files directly over an
https://azure.microsoft.com/es-es/products/storage/blobs[_Azure Blob Storage]_. And we also recover it for there.

'''

==== Real-time sharing and transport of the shared-state

This is done using one of **Weave.js’s** supported store providers, internally using _Yjs_ as the shared-state manager. We provide
the following store providers:

* **Websockets** store provider, which uses the https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API[_Websockets API_] as
transport.
* **Azure Web PubSub** store provider, which uses https://azure.microsoft.com/en-us/products/web-pubsub[_Azure Web PubSub_]
as transport.

Developers can also write a store with their custom transport. For example like using AWS AppSync as transport.

'''

==== Awareness events [Optional]

Awareness events are fundamental part of a collaborative application. The first part of a collaborative application in
order to work seamlessly among all clients is to manage and sync a shared-state that models our application. But we also
can share more information that helps our users to work together, for example let know when an user joins or leaves the
collaboration room or when a user is performing an action, etc. This kind of information is generally denominated as
"Awareness" information.

We could share a lot of awareness information like for example mouse position of each user. But when we share too much
awareness information, we distract our users from the task at hand. So it is important to find the right balance, that
makes sense for your application.

Awareness information isn't stored in the shared-state, as it doesn't need to be persisted across sessions. We relay on
_Yjs_ link:https://docs.yjs.dev/getting-started/adding-awareness[Awareness] that propagates JSON objects to all users.

All of our store providers implement the Awareness protocol.
